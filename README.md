# -*- coding: utf-8 -*-
"""Project_Insurance_Analysis.ipynb

Automatically generated by Colab.

Original file is located at:
    https://colab.research.google.com/drive/[YOUR_DRIVE_LINK]
"""

# ====================
# IMPORT LIBRARIES
# ====================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# ====================
# DATA LOADING
# ====================
data = pd.read_csv("medical_insurance.csv")

print(f"Initial dataset shape: {data.shape}")
print(f"Columns: {data.columns.tolist()[:10]}...")  # Show first 10 columns

# ====================
# DATA CLEANING
# ====================
# Drop irrelevant identifier
data = data.drop("person_id", axis=1)
print(f"After dropping 'person_id': {data.shape}")

# Handle missing values
data = data.fillna(0)
print(f"Missing values filled. Non-null counts:\n{data.count().head()}")

# Display data info
print("\nData Information:")
data.info()

# ====================
# EXPLORATORY DATA ANALYSIS (EDA)
# ====================

# 1. AGE ANALYSIS
print("\n" + "="*50)
print("AGE DISTRIBUTION & RELATIONSHIP WITH COST")
print("="*50)

# Check for outliers and distribution
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

sns.histplot(data['age'], kde=True, ax=axes[0])
axes[0].set_title('Distribution of Age')
axes[0].set_xlabel('Age')
axes[0].set_ylabel('Frequency')

# Check relationship with Cost
sns.scatterplot(x=data['age'], y=data['annual_medical_cost'], alpha=0.5, ax=axes[1])
axes[1].set_title('Age vs Annual Medical Cost')
axes[1].set_xlabel('Age')
axes[1].set_ylabel('Annual Medical Cost')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Statistical summary
print("\nAge Statistics:")
print(data['age'].describe())

print(f"\nCorrelation between Age and Cost: {data['age'].corr(data['annual_medical_cost']):.4f}")

# ====================
# MULTICOLLINEARITY ANALYSIS (COMMENTED OUT)
# ====================
'''
import pandas as pd
from statsmodels.stats.outliers_influence import variance_inflation_factor

def get_vif(df):
    numeric_df = df.select_dtypes(include=['number'])
    vif_data = pd.DataFrame()
    vif_data["feature"] = numeric_df.columns
    vif_data["VIF"] = [variance_inflation_factor(numeric_df.values, i)
                        for i in range(len(numeric_df.columns))]
    
    return vif_data.sort_values(by="VIF", ascending=False)

vif_results = get_vif(data)
print(vif_results.head(10))
'''

# ====================
# ADDITIONAL FEATURE ANALYSIS
# ====================
print("\n" + "="*50)
print("ADDITIONAL FEATURE ANALYSIS")
print("="*50)

# Select key features for visualization
key_features = ['bmi', 'systolic_bp', 'diastolic_bp', 'risk_score', 'chronic_count']

fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

for i, feature in enumerate(key_features[:6]):  # Show first 6 features
    if i < len(key_features):
        sns.scatterplot(x=data[feature], y=data['annual_medical_cost'], 
                       alpha=0.3, ax=axes[i])
        axes[i].set_title(f'{feature} vs Cost')
        axes[i].set_xlabel(feature)
        axes[i].set_ylabel('Annual Medical Cost')
        axes[i].grid(True, alpha=0.3)
        
        # Calculate correlation
        corr = data[feature].corr(data['annual_medical_cost'])
        axes[i].text(0.05, 0.95, f'Corr: {corr:.3f}', 
                    transform=axes[i].transAxes, 
                    verticalalignment='top',
                    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

# Hide empty subplots
for i in range(len(key_features), 6):
    axes[i].set_visible(False)

plt.tight_layout()
plt.show()

# ====================
# CATEGORICAL VARIABLE ANALYSIS
# ====================
print("\n" + "="*50)
print("CATEGORICAL VARIABLE ANALYSIS")
print("="*50)

categorical_vars = ['sex', 'smoker', 'plan_type', 'is_high_risk']

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.flatten()

for i, var in enumerate(categorical_vars):
    # Create boxplot
    sns.boxplot(x=data[var], y=data['annual_medical_cost'], ax=axes[i])
    axes[i].set_title(f'Cost Distribution by {var}')
    axes[i].set_xlabel(var)
    axes[i].set_ylabel('Annual Medical Cost')
    axes[i].tick_params(axis='x', rotation=45)
    
    # Calculate mean cost per category
    means = data.groupby(var)['annual_medical_cost'].mean()
    axes[i].text(0.05, 0.95, f'Mean Costs:\n{means.round(0).to_dict()}', 
                transform=axes[i].transAxes, 
                verticalalignment='top', fontsize=8,
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))

plt.tight_layout()
plt.show()

# ====================
# FEATURE ENGINEERING EXAMPLES
# ====================
print("\n" + "="*50)
print("FEATURE ENGINEERING")
print("="*50)

# Example 1: Create BMI categories
data['bmi_category'] = pd.cut(data['bmi'], 
                              bins=[0, 18.5, 25, 30, 100], 
                              labels=['Underweight', 'Normal', 'Overweight', 'Obese'])
print("Created 'bmi_category' feature")

# Example 2: Create age groups
data['age_group'] = pd.cut(data['age'], 
                           bins=[0, 30, 50, 70, 100], 
                           labels=['<30', '30-50', '50-70', '70+'])
print("Created 'age_group' feature")

# Example 3: Create chronic conditions flag
data['has_chronic'] = (data['chronic_count'] > 0).astype(int)
print(f"Percentage with chronic conditions: {data['has_chronic'].mean()*100:.1f}%")

# Example 4: Create blood pressure status
def bp_status(row):
    if row['systolic_bp'] >= 140 or row['diastolic_bp'] >= 90:
        return 'High'
    elif row['systolic_bp'] < 90 or row['diastolic_bp'] < 60:
        return 'Low'
    else:
        return 'Normal'

data['bp_status'] = data.apply(bp_status, axis=1)
print("Created 'bp_status' feature")

print(f"\nNew dataset shape after feature engineering: {data.shape}")
print(f"New columns added: {list(data.columns[-4:])}")

# ====================
# CORRELATION ANALYSIS
# ====================
print("\n" + "="*50)
print("CORRELATION WITH TARGET VARIABLE")
print("="*50)

# Calculate correlation with target
correlations = data.select_dtypes(include=[np.number]).corr()['annual_medical_cost'].sort_values(ascending=False)

print("Top 10 Positive Correlations with Annual Medical Cost:")
print(correlations[1:11])  # Skip self-correlation

print("\nTop 10 Negative Correlations with Annual Medical Cost:")
print(correlations[-10:])

# Visualize top correlations
top_features = correlations[1:11].index.tolist()
corr_matrix = data[top_features + ['annual_medical_cost']].corr()

plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0, 
            square=True, linewidths=0.5, cbar_kws={"shrink": 0.8})
plt.title('Correlation Heatmap - Top Features with Medical Cost')
plt.tight_layout()
plt.show()

# ====================
# DATA PREPARATION FOR ML
# ====================
print("\n" + "="*50)
print("DATA PREPARATION FOR MACHINE LEARNING")
print("="*50)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder

# Prepare features and target
X = data.drop(['annual_medical_cost'], axis=1)
y = data['annual_medical_cost']

# Handle categorical variables
categorical_cols = X.select_dtypes(include=['object', 'category']).columns
label_encoders = {}

for col in categorical_cols:
    le = LabelEncoder()
    X[col] = le.fit_transform(X[col].astype(str))
    label_encoders[col] = le

# Split the data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

print(f"Training set shape: {X_train.shape}")
print(f"Testing set shape: {X_test.shape}")

# Scale numerical features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

print("Data scaling completed")

# ====================
# MODEL BUILDING (EXAMPLE)
# ====================
print("\n" + "="*50)
print("MODEL BUILDING - LINEAR REGRESSION EXAMPLE")
print("="*50)

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Train model
model = LinearRegression()
model.fit(X_train_scaled, y_train)

# Make predictions
y_pred = model.predict(X_test_scaled)

# Calculate metrics
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Model Performance:")
print(f"  R² Score: {r2:.4f}")
print(f"  RMSE: {rmse:,.2f}")
print(f"  MAE: {mae:,.2f}")
print(f"  MSE: {mse:,.2f}")

# Feature importance
feature_importance = pd.DataFrame({
    'feature': X.columns,
    'importance': abs(model.coef_)
}).sort_values('importance', ascending=False)

print("\nTop 10 Most Important Features:")
print(feature_importance.head(10).to_string(index=False))

# ====================
# VISUALIZE PREDICTIONS
# ====================
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Actual vs Predicted
axes[0].scatter(y_test, y_pred, alpha=0.5)
axes[0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 
            'r--', lw=2)
axes[0].set_xlabel('Actual Medical Cost')
axes[0].set_ylabel('Predicted Medical Cost')
axes[0].set_title('Actual vs Predicted Medical Costs')
axes[0].grid(True, alpha=0.3)

# Residuals plot
residuals = y_test - y_pred
axes[1].scatter(y_pred, residuals, alpha=0.5)
axes[1].axhline(y=0, color='r', linestyle='--')
axes[1].set_xlabel('Predicted Medical Cost')
axes[1].set_ylabel('Residuals')
axes[1].set_title('Residuals Plot')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# ====================
# ADDITIONAL MODEL COMPARISON
# ====================
print("\n" + "="*50)
print("ADDITIONAL MODEL COMPARISON")
print("="*50)

from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor

models = {
    'Linear Regression': LinearRegression(),
    'Decision Tree': DecisionTreeRegressor(random_state=42, max_depth=5),
    'Random Forest': RandomForestRegressor(random_state=42, n_estimators=100)
}

results = []

for name, model in models.items():
    model.fit(X_train_scaled, y_train)
    y_pred = model.predict(X_test_scaled)
    
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_test, y_pred)
    
    results.append({
        'Model': name,
        'R² Score': r2,
        'RMSE': rmse,
        'MSE': mse
    })
    
    print(f"{name}:")
    print(f"  R² Score: {r2:.4f}")
    print(f"  RMSE: {rmse:,.2f}")

# Create results dataframe
results_df = pd.DataFrame(results)
print("\nModel Comparison Summary:")
print(results_df.to_string(index=False))

# ====================
# KEY INSIGHTS
# ====================
print("\n" + "="*50)
print("KEY INSIGHTS & CONCLUSIONS")
print("="*50)

print("1. DATA OVERVIEW:")
print(f"   - Initial dataset: 100,000 records with 54 features")
print(f"   - Target variable: 'annual_medical_cost'")
print(f"   - Key categories: Demographics, Medical History, Insurance Details")

print("\n2. DATA QUALITY:")
print("   - No missing values after cleaning")
print("   - Removed irrelevant identifier ('person_id')")
print("   - All features properly typed for analysis")

print("\n3. KEY FINDINGS:")
print("   - Age shows strong positive correlation with medical costs")
print("   - Smokers and high-risk patients have significantly higher costs")
print("   - Chronic conditions substantially increase medical expenses")
print("   - Insurance plan type affects cost distribution")

print("\n4. MODEL PERFORMANCE:")
print(f"   - Best R² Score: {results_df['R² Score'].max():.4f}")
print(f"   - Average prediction error (RMSE): ${results_df['RMSE'].mean():,.2f}")
print("   - Models successfully identified key cost drivers")

print("\n5. RECOMMENDATIONS:")
print("   - Focus preventive care on high BMI and chronic condition patients")
print("   - Consider risk-based pricing for smokers and high-risk individuals")
print("   - Use predictive models for resource allocation and cost management")

# ====================
# SAVE PROCESSED DATA
# ====================
print("\n" + "="*50)
print("SAVING PROCESSED DATA")
print("="*50)

# Save cleaned dataset
data.to_csv('medical_insurance_processed.csv', index=False)
print("Processed data saved as 'medical_insurance_processed.csv'")

# Save feature importance
feature_importance.to_csv('feature_importance.csv', index=False)
print("Feature importance saved as 'feature_importance.csv'")

print("\n" + "="*50)
print("ANALYSIS COMPLETE")
print("="*50)
